% Johann Diep (jdiep@student.ethz.ch) - May 2019

% This program implements the method towards anchor position calibration
% described in the paper "Iterative approach for anchor configuration of
% positioning systems" by Mathias Pelka, Grigori Goronzy and Horst
% Hellbrueck.

function anchor_pos = AnchorCalibration(anchor_range_mean,plotting)
    %% Hardcoding values
    
    anchor_range_mean = anchor_range_mean/1000; % transform to [m] unit
    anchors = 8; % number of anchors
    height_top = 2.43; % anchor heights

    %% Preprocessing range data

    for i = 1:anchors
        for j = 1:anchors
            ranges_averaged(i,j) = (anchor_range_mean(i,j) + anchor_range_mean(j,i))/2;
        end
    end
            
    %% Parameters to estimate
     
    % placement of the anchors
    % anchor 1 is set to be the origin of the coordinate system
    % anchor 3, 6 and 8 are fixed on the same height as anchor 1
    % anchor 2, 4, 5 and 7 are fixed at a known constant height
    % anchor 6 is assumed to be on the same axis without loss of generality
    % top anchors are assumed to have same x/y-coordinates as bottom anchors
    syms a_3_x a_4_x
    syms a_3_y a_4_y
    anchor_pos = [0,0,0; ...
        0,a_2_y,height_top; ...
        a_3_x,a_3_y,0; ...
        a_4_x,a_4_y,height_top; ...
        0,0,height_top; ...
        0,a_2_y,0; ...
        a_3_x,a_3_y,height_top; ...
        a_4_x,a_4_y,0];
    a_p = [a_3_x,a_3_y,a_4_x,a_4_y];
    
    %% Objective function to minimize
    
    index = 1; 
    f = sym(zeros(28,1));
    
    %ranging constraints
    for i = 1:anchors
        for j = 1:anchors
            if j == i || isequal([i,j],permute([i,j],[1,2])') % avoid identity and equal comparisons
                break;
            end
            f(index) =  sqrt((anchor_pos(i,1)-anchor_pos(j,1))^2 + ...
                (anchor_pos(i,2)-anchor_pos(j,2))^2 + ...
                (anchor_pos(i,3)-anchor_pos(j,3))^2) - ranges_averaged(i,j);
            index = index + 1;
        end
    end
        
    %% Gauss-Newton algorithm
    
    fp = jacobian(f,a_p); % calculate Jacobian
    
    % convert symbolic expression to function handle
    f = matlabFunction(f);
    fp = matlabFunction(fp);    
    
    % allow function to handle array input
    f = convertToAcceptArray(f);
    fp = convertToAcceptArray(fp);
    
    % initialization
    % a_i = normrnd(10,0.1,[1,size(a_p,2)]);
    a_i = [10.0553,10.1039,9.8882,10.1261,10.0660];
        
    while true
        b = f(a_i); % evaluate f
        A = fp(a_i); % evaluate Jacobian
        d = -A\b; % solve linear least squares problem
        
        % update
        opa = a_i + d';
        a_i = opa;
        
        if norm(d) <= 1e-10 % stop iteration if norm(d) passes a tolerance
            break
        end
    end
    
    %% Plotting
    
    anchor_pos = [0,0,0; ...
        a_i(1),a_i(2),height_top; ...
        a_i(3),a_i(4),0; ...
        a_i(5),a_i(6),height_top; ...
        a_i(7),a_i(8),height_top; ...
        0,a_i(9),0; ...
        a_i(10),a_i(11),height_top; ...
        a_i(12),a_i(13),0];

    if plotting == true
        figure()
        hold on
        title("Flying arena coordinate system");
        xlabel("x-Axis [m]");
        ylabel("y-Axis [m]");
        zlabel("z-Axis [m]");
        grid on

        scatter3(anchor_pos(:,1),anchor_pos(:,2),anchor_pos(:,3),'MarkerFaceColor',[0,0,0]);

        line([anchor_pos(1,1),anchor_pos(5,1)],[anchor_pos(1,2),anchor_pos(5,2)],[anchor_pos(1,3),anchor_pos(5,3)],'Color',[.5,.5,.5]);
        line([anchor_pos(8,1),anchor_pos(4,1)],[anchor_pos(8,2),anchor_pos(4,2)],[anchor_pos(8,3),anchor_pos(4,3)],'Color',[.5,.5,.5]);
        line([anchor_pos(6,1),anchor_pos(2,1)],[anchor_pos(6,2),anchor_pos(2,2)],[anchor_pos(6,3),anchor_pos(2,3)],'Color',[.5,.5,.5]);
        line([anchor_pos(3,1),anchor_pos(7,1)],[anchor_pos(3,2),anchor_pos(7,2)],[anchor_pos(3,3),anchor_pos(7,3)],'Color',[.5,.5,.5]);

        for i = 1:size(anchor_pos,1)
            text(anchor_pos(i,1)+0.1,anchor_pos(i,2)+0.1,anchor_pos(i,3)+0.1,"Anchor " + int2str(i));
        end
    end
end